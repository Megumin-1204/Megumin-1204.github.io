<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础知识1 | 忘歸人</title><meta name="author" content="Megumin"><meta name="copyright" content="Megumin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C#1.装箱和拆箱是什么？ 装箱（Boxing）：将值类型转换为引用类型的过程。例如，将一个 int 类型的值赋值给一个 object 类型的变量时，会发生装箱操作。装箱会在堆上分配内存，并将值类型的值复制到该内存中。  12int i &#x3D; 123;object o &#x3D; i;  &#x2F;&#x2F; 装箱   拆箱（Unboxing）：将引用类型转换回值类型的过程。拆箱操作会检查引用类型是否与目标值类型兼容，并将">
<meta property="og:type" content="article">
<meta property="og:title" content="基础知识1">
<meta property="og:url" content="https://megumin.github.io.git/2025/03/02/Passage/Note1/index.html">
<meta property="og:site_name" content="忘歸人">
<meta property="og:description" content="C#1.装箱和拆箱是什么？ 装箱（Boxing）：将值类型转换为引用类型的过程。例如，将一个 int 类型的值赋值给一个 object 类型的变量时，会发生装箱操作。装箱会在堆上分配内存，并将值类型的值复制到该内存中。  12int i &#x3D; 123;object o &#x3D; i;  &#x2F;&#x2F; 装箱   拆箱（Unboxing）：将引用类型转换回值类型的过程。拆箱操作会检查引用类型是否与目标值类型兼容，并将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://megumin.github.io.git/img/heita1.jpg">
<meta property="article:published_time" content="2025-03-02T14:00:00.000Z">
<meta property="article:modified_time" content="2025-03-02T14:17:22.824Z">
<meta property="article:author" content="Megumin">
<meta property="article:tag" content="めぐみん">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://megumin.github.io.git/img/heita1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://megumin.github.io.git/2025/03/02/Passage/Note1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础知识1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/chuyin.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/makima.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/heita1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">忘歸人</span></a><a class="nav-page-title" href="/"><span class="site-name">基础知识1</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基础知识1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-02T14:00:00.000Z" title="发表于 2025-03-02 22:00:00">2025-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-02T14:17:22.824Z" title="更新于 2025-03-02 22:17:22">2025-03-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h2 id="1-装箱和拆箱是什么？"><a href="#1-装箱和拆箱是什么？" class="headerlink" title="1.装箱和拆箱是什么？"></a>1.装箱和拆箱是什么？</h2><ul>
<li>装箱（Boxing）：将值类型转换为引用类型的过程。例如，将一个 int 类型的值赋值给一个 object 类型的变量时，会发生装箱操作。装箱会在堆上分配内存，并将值类型的值复制到该内存中。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">object</span> o = i;  <span class="comment">// 装箱</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拆箱（Unboxing）：将引用类型转换回值类型的过程。拆箱操作会检查引用类型是否与目标值类型兼容，并将堆中的值复制回值类型变量中。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> j = (<span class="built_in">int</span>)o;  <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure>

<p>补充：</p>
<ul>
<li><p>装箱——把栈中内容迁移到堆中去（值转引用）</p>
</li>
<li><p>拆箱——把堆中内容迁移到栈中去（引用转值）</p>
</li>
</ul>
<h2 id="2-值和引用类型在变量赋值时的区别是什么？"><a href="#2-值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="2.值和引用类型在变量赋值时的区别是什么？"></a>2.值和引用类型在变量赋值时的区别是什么？</h2><p>值类型（Value Type）：</p>
<ul>
<li>值类型的变量直接包含其数据。</li>
<li>赋值时，会将数据复制一份给新的变量。</li>
<li>修改一个变量的值不会影响另一个变量的值。</li>
</ul>
<p>常见值类型包括 int、float、bool、struct 等。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b = a;  <span class="comment">// b 是 a 的副本</span></span><br><span class="line">b = <span class="number">20</span>;     <span class="comment">// 修改 b 不会影响 a</span></span><br><span class="line">Console.WriteLine(a);  <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>

<h2 id="3-委托和事件在使用上的区别是什么？"><a href="#3-委托和事件在使用上的区别是什么？" class="headerlink" title="3.委托和事件在使用上的区别是什么？"></a>3.委托和事件在使用上的区别是什么？</h2><p>委托（Delegate）：</p>
<ul>
<li>委托是一种类型安全的函数指针，用于封装一个或多个方法。</li>
<li>委托可以用于调用方法，也可以作为参数传递给其他方法。</li>
<li>委托可以显式调用，并且可以用于实现回调机制。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyDelegate del = <span class="keyword">new</span> MyDelegate(DisplayMessage);</span><br><span class="line">del(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>事件（Event）：</p>
<ul>
<li>事件是基于委托的，用于实现发布-订阅模式。</li>
<li>事件只能在声明它的类内部触发，外部类只能订阅或取消订阅事件。</li>
<li>事件通常用于通知其他对象发生了某些动作或状态变化。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> MyDelegate MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MyEvent(<span class="string">&quot;Event Raised!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.MyEvent += DisplayMessage;</span><br><span class="line">obj.RaiseEvent();  <span class="comment">// 输出 &quot;Event Raised!&quot;</span></span><br></pre></td></tr></table></figure>
区别：</li>
<li>委托可以直接调用，而事件只能在声明它的类内部触发。</li>
<li>事件提供了更好的封装性，外部类只能订阅或取消订阅事件，而不能直接调用或修改事件。</li>
</ul>
<h2 id="4-有两个接口IA和IB，他们中有一个同名方法Test-。一个类同时继承这两个接口，应该如何处理他们的同名方法？"><a href="#4-有两个接口IA和IB，他们中有一个同名方法Test-。一个类同时继承这两个接口，应该如何处理他们的同名方法？" class="headerlink" title="4.有两个接口IA和IB，他们中有一个同名方法Test()。一个类同时继承这两个接口，应该如何处理他们的同名方法？"></a>4.有两个接口IA和IB，他们中有一个同名方法Test()。一个类同时继承这两个接口，应该如何处理他们的同名方法？</h2><p>当一个类实现多个接口，并且这些接口中有同名方法时，可以使用显式接口实现来区分它们。显式接口实现通过在方法名前加上接口名称来指定该方法属于哪个接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IA</span>, <span class="title">IB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Test()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IA.Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IB.Test()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IB.Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">((IA)obj).Test();  <span class="comment">// 输出 &quot;IA.Test&quot;</span></span><br><span class="line">((IB)obj).Test();  <span class="comment">// 输出 &quot;IB.Test&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过显式接口实现，可以避免方法名的冲突，并且在使用时需要将对象强制转换为相应的接口类型来调用对应的方法。</p>
<h2 id="5-C-中的List是如何扩容的"><a href="#5-C-中的List是如何扩容的" class="headerlink" title="5.C#中的List是如何扩容的"></a>5.C#中的List是如何扩容的</h2><p>List<T> 是 C# 中常用的动态数组，它可以根据需要自动扩容。List<T> 的内部实现是基于数组的，当元素数量超过当前容量时，List<T> 会自动扩容。</p>
<p>扩容机制：</p>
<ul>
<li>初始容量：List<T> 在创建时有一个初始容量（默认是 0 或 4，具体取决于构造函数）。</li>
<li>添加元素：当向 List<T> 中添加元素时，如果当前元素数量已经达到容量上限，List<T> 会触发扩容。</li>
<li>扩容策略：List<T> 的扩容策略是创建一个新的数组，新数组的容量通常是当前容量的两倍（具体倍数可能因版本不同而有所变化）。然后将旧数组中的元素复制到新数组中。</li>
<li>性能考虑：扩容操作会带来一定的性能开销，因为涉及到内存分配和元素复制。为了避免频繁扩容，可以在创建 List<T> 时指定一个较大的初始容量。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();  <span class="comment">// 初始容量为 0</span></span><br><span class="line">list.Add(<span class="number">1</span>);  <span class="comment">// 容量扩容到 4</span></span><br><span class="line">list.Add(<span class="number">2</span>);</span><br><span class="line">list.Add(<span class="number">3</span>);</span><br><span class="line">list.Add(<span class="number">4</span>);</span><br><span class="line">list.Add(<span class="number">5</span>);  <span class="comment">// 容量扩容到 8</span></span><br></pre></td></tr></table></figure>
手动设置容量：<br>为了避免频繁扩容，可以在创建 List<T> 时指定一个初始容量，或者在需要时手动调整容量。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 初始容量为 100</span></span><br><span class="line">list.Capacity = <span class="number">200</span>;  <span class="comment">// 手动调整容量</span></span><br></pre></td></tr></table></figure>
通过合理设置初始容量，可以减少扩容操作的次数，从而提高性能。</li>
</ul>
<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="1-Unity中点乘和叉乘对于我们来说的作用是什么？"><a href="#1-Unity中点乘和叉乘对于我们来说的作用是什么？" class="headerlink" title="1.Unity中点乘和叉乘对于我们来说的作用是什么？"></a>1.Unity中点乘和叉乘对于我们来说的作用是什么？</h2><p>点乘（Dot Product）：</p>
<ul>
<li>点乘是两个向量的标量积，结果是一个标量值。</li>
<li>在 Unity 中，点乘常用于计算两个向量之间的夹角、判断两个向量的方向关系（如是否同向、反向或垂直）。</li>
<li>点乘还可以用于投影计算，例如计算一个向量在另一个向量上的投影长度。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3 a = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 b = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">float</span> dot = Vector3.Dot(a, b);  <span class="comment">// 结果为 0，表示两个向量垂直</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>叉乘（Cross Product）：</p>
<ul>
<li>叉乘是两个向量的向量积，结果是一个新的向量。</li>
<li>在 Unity 中，叉乘常用于计算两个向量的垂直向量（法向量），例如计算平面的法向量或旋转轴。</li>
<li>叉乘还可以用于计算两个向量的夹角方向（顺时针或逆时针）。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3 a = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 b = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 cross = Vector3.Cross(a, b);  <span class="comment">// 结果为 (0, 0, 1)，表示垂直于 a 和 b 的向量</span></span><br></pre></td></tr></table></figure>
作用：</li>
<li>点乘和叉乘在 Unity 中广泛应用于物理模拟、碰撞检测、光照计算、相机控制等场景。</li>
<li>点乘用于判断方向和投影，叉乘用于计算法向量和旋转轴。</li>
</ul>
<p>补充：</p>
<p>点乘作用：</p>
<ul>
<li>判断对象的方位</li>
<li>计算两向量之间的夹角</li>
</ul>
<p>叉乘作用：</p>
<ul>
<li>获取一个平面的法向量</li>
<li>得到两向量之间的左右位置关系</li>
</ul>
<h2 id="2-Unity中多线程执行下面哪些代码会报错？"><a href="#2-Unity中多线程执行下面哪些代码会报错？" class="headerlink" title="2. Unity中多线程执行下面哪些代码会报错？"></a>2. Unity中多线程执行下面哪些代码会报错？</h2><p>在 Unity 中，主线程负责处理与 Unity 引擎相关的操作（如 GameObject、Transform、渲染等），而多线程不能直接访问这些 Unity API，否则会报错。</p>
<p>以下代码在多线程中执行是否会报错：</p>
<p>A. Application.persistentDataPath：</p>
<ul>
<li>不会报错。Application.persistentDataPath 是一个只读属性，返回应用程序的持久化数据路径，可以在多线程中安全访问。</li>
</ul>
<p>B. File.Exists(“文件名”)：</p>
<ul>
<li>不会报错。File.Exists 是 .NET 的 API，与 Unity 引擎无关，可以在多线程中安全调用。</li>
</ul>
<p>C. transform.Translate：</p>
<ul>
<li>会报错。transform.Translate 是 Unity 的 API，涉及到 GameObject 的 Transform 组件，必须在主线程中调用。</li>
</ul>
<p>D. Object.Destroy(对象)：</p>
<ul>
<li>会报错。Object.Destroy 是 Unity 的 API，用于销毁 GameObject 或组件，必须在主线程中调用。</li>
</ul>
<p>总结：</p>
<ul>
<li>会报错的选项：C 和 D。</li>
<li>不会报错的选项：A 和 B。</li>
</ul>
<p>补充：A C D, UnityEngine命名空间中相关类基本都不能被Unity中多线程使用</p>
<h2 id="3-Application-streamingAssetsPath-和-Application-persistentDataPath-的区别"><a href="#3-Application-streamingAssetsPath-和-Application-persistentDataPath-的区别" class="headerlink" title="3. Application.streamingAssetsPath 和 Application.persistentDataPath 的区别"></a>3. Application.streamingAssetsPath 和 Application.persistentDataPath 的区别</h2><p>Application.streamingAssetsPath：</p>
<ul>
<li>Assets&#x2F;StreamingAssets&#x2F; 目录下的文件，只读，打包后不会更改</li>
<li>用于存放游戏资源，如配置文件、内置数据（不会被用户修改）</li>
</ul>
<p>Application.persistentDataPath：</p>
<ul>
<li>设备上的可读写存储目录，存储游戏数据</li>
<li>存储用户数据，如存档、下载资源等</li>
</ul>
<p>具体区别：</p>
<ul>
<li><p>streamingAssetsPath 是 应用内资源，打包时放入 StreamingAssets&#x2F; 目录，不能修改。</p>
</li>
<li><p>persistentDataPath 是 用户数据存储路径，可以在运行时读写。</p>
</li>
<li><p>streamingAssetsPath 在 PC 上是一个文件夹，但在 Android&#x2F;iOS 上可能是 apk 或 bundle 内的资源，需要通过 WWW 或 UnityWebRequest 读取。</p>
</li>
<li><p>persistentDataPath 是 跨平台的读写路径，适用于存储存档、日志、下载内容。</p>
</li>
</ul>
<p>补充：</p>
<ul>
<li>Application.streamingAssetsPath 只读，适合放置一些默认2进制配置文件</li>
<li>Application.persistentDataPath 可读可写，用于处理数据持久化，或作为热更新下载内容的存放目录</li>
</ul>
<h2 id="4-Unity-中协程的原理"><a href="#4-Unity-中协程的原理" class="headerlink" title="4.Unity 中协程的原理"></a>4.Unity 中协程的原理</h2><p>协程（Coroutine）：</p>
<ul>
<li>协程是 Unity 中一种特殊的函数，可以在执行过程中暂停，并在稍后的时间点继续执行。</li>
<li>协程通过 IEnumerator 接口实现，使用 yield 关键字来暂停执行。</li>
</ul>
<p>原理：</p>
<p>1.迭代器模式：</p>
<ul>
<li>协程本质上是一个迭代器，通过 IEnumerator 接口实现。</li>
<li>yield return 语句会返回一个值，并暂停协程的执行，直到下一次调用 MoveNext()。</li>
</ul>
<p>2.Unity 的协程调度器：</p>
<ul>
<li>Unity 在主线程中维护了一个协程调度器，负责管理所有协程的执行。</li>
<li>协程的恢复条件由 yield return 后面的对象决定，例如：<ul>
<li>yield return null：等待下一帧继续执行。</li>
<li>yield return new WaitForSeconds(2)：等待 2 秒后继续执行。</li>
<li>yield return new WaitUntil(() &#x3D;&gt; condition)：等待条件满足后继续执行。</li>
</ul>
</li>
</ul>
<p>3.执行流程：</p>
<ul>
<li>协程启动后，Unity 会将其加入调度器。</li>
<li>每次更新时，调度器会检查协程的恢复条件是否满足。</li>
<li>如果满足，协程会从上次暂停的位置继续执行。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;  <span class="comment">// 暂停 1 秒</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;After 1 second&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
意义：</li>
<li>协程非常适合用于实现延时、分帧加载、动画控制等需要暂停和恢复的场景。</li>
</ul>
<p>补充：<br>Unity中的协同程序分为两部分</p>
<ul>
<li>协程函数本体（迭代器函数）</li>
<li>协程调度器（协程管理器）</li>
<li>协程利用迭代器函数的分步执行的特点，加上协程调度器对迭代器函数们进行统一管理，，根据迭代器函数的返回值来决定下一次执行函数逻辑的时间点，从而实现逻辑分时分步执行的目的</li>
</ul>
<h2 id="5-Unity-底层如何处理-C-代码？"><a href="#5-Unity-底层如何处理-C-代码？" class="headerlink" title="5.Unity 底层如何处理 C# 代码？"></a>5.Unity 底层如何处理 C# 代码？</h2><ol start="5">
<li>Unity 底层如何处理 C# 代码？<br>Unity 底层对 C# 代码的处理主要分为以下几个步骤：</li>
</ol>
<ul>
<li><p>编译：</p>
<ul>
<li>Unity 使用 Mono 或 IL2CPP 作为脚本后端。</li>
<li>在开发阶段，C# 代码会被编译为 CIL（Common Intermediate Language，中间语言）。</li>
<li>如果使用 IL2CPP，CIL 会进一步编译为 C++ 代码，然后再编译为平台原生的机器码。</li>
</ul>
</li>
<li><p>执行：</p>
<ul>
<li>在运行时，Unity 通过 Mono 或 IL2CPP 执行编译后的代码。</li>
<li>Mono 是一个跨平台的 .NET 运行时，直接解释或 JIT（Just-In-Time）编译 CIL 代码。</li>
<li>IL2CPP 将 CIL 转换为 C++ 代码，再编译为原生机器码，性能更高，但构建时间更长。</li>
</ul>
</li>
<li><p>与引擎交互：</p>
<ul>
<li>Unity 引擎的核心是用 C++ 编写的。</li>
<li>C# 脚本通过 P&#x2F;Invoke（平台调用）或绑定层与引擎核心交互。</li>
<li>例如，调用 transform.Translate 时，C# 代码会通过绑定层调用引擎的 C++ 实现。</li>
</ul>
</li>
<li><p>垃圾回收：</p>
<ul>
<li>Unity 使用 Mono 或 IL2CPP 的垃圾回收器（GC）来管理内存。</li>
<li>GC 会自动回收不再使用的对象，但频繁的 GC 可能会导致性能问题。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>Unity 将 C# 代码编译为中间语言，再通过 Mono 或 IL2CPP 执行。</li>
<li>C# 脚本通过绑定层与引擎核心交互。</li>
<li>垃圾回收由 Mono 或 IL2CPP 管理，开发者需要注意内存使用以避免性能问题。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Megumin.github.io.git">Megumin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://megumin.github.io.git/2025/03/02/Passage/Note1/">https://megumin.github.io.git/2025/03/02/Passage/Note1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Megumin.github.io.git" target="_blank">忘歸人</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/heita1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/02/Passage/Note2/" title="基础知识2"><img class="cover" src="/img/liuying2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基础知识2</div></div><div class="info-2"><div class="info-item-1">C#1.C# 中 &#x3D;&#x3D; 和 Equals 的区别是什么？&#x3D;&#x3D; 运算符：  &#x3D;&#x3D; 是一个运算符，用于比较两个变量的值是否相等。 对于值类型，&#x3D;&#x3D; 比较的是两个变量的实际值。 对于引用类型，&#x3D;&#x3D; 比较的是两个变量的引用（即内存地址）是否相同，而不是它们的内容。 &#x3D;&#x3D; 可以被重载，例如在自定义类中重载 &#x3D;&#x3D; 以实现特定的比较逻辑。  Equals 方法：  Equals 是一个方法，定义在 System.Object 类中，所有类型都继承了这个方法。 对于值类型，Equals 比较的是两个变量的实际值（与 &#x3D;&#x3D; 类似）。 对于引用类型，Equals 的默认行为是比较两个变量的引用是否相同（与 &#x3D;&#x3D; 类似），但可以被重写以实现内容比较。 Equals 是一个虚方法，可以在自定义类中重写以实现自定义的相等性比较逻辑。  区别：  比较方式：  &#x3D;&#x3D; 是一个运算符，Equals...</div></div></div></a><a class="pagination-related" href="/2024/11/26/hello-world/" title="Hello World"><img class="cover" src="https://picsum.photos/id/16/2500/1667" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/makima.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Megumin</div><div class="author-info-description">黒より黒く闇より暗き漆黒に我が深紅の混淆を望みたもう。覚醒のとき来たれり。無謬の境界に落ちし理。無行の歪みとなりて現出せよ！踊れ踊れ踊れ、我が力の奔流に望むは崩壊なり。並ぶ者なき崩壊なり。万象等しく灰塵に帰し、深淵より来たれ！これが人類最大の威力の攻撃手段、これこそが究極の攻撃魔法、エクスプロージョン！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Megumin-1204" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1725603185@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C"><span class="toc-number">1.</span> <span class="toc-text">C#</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.装箱和拆箱是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.值和引用类型在变量赋值时的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3.委托和事件在使用上的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3IA%E5%92%8CIB%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95Test-%E3%80%82%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BF%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%96%E4%BB%AC%E7%9A%84%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.有两个接口IA和IB，他们中有一个同名方法Test()。一个类同时继承这两个接口，应该如何处理他们的同名方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-C-%E4%B8%AD%E7%9A%84List%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">5.C#中的List是如何扩容的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity"><span class="toc-number">2.</span> <span class="toc-text">Unity</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Unity%E4%B8%AD%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E6%9D%A5%E8%AF%B4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1.Unity中点乘和叉乘对于我们来说的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Unity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. Unity中多线程执行下面哪些代码会报错？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Application-streamingAssetsPath-%E5%92%8C-Application-persistentDataPath-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">3. Application.streamingAssetsPath 和 Application.persistentDataPath 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Unity-%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">4.Unity 中协程的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Unity-%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-C-%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.Unity 底层如何处理 C# 代码？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/02/Passage/LuaRequireAndPackageLoaded/" title="Lua中的require与package.loaded"><img src="/img/heita1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua中的require与package.loaded"/></a><div class="content"><a class="title" href="/2025/04/02/Passage/LuaRequireAndPackageLoaded/" title="Lua中的require与package.loaded">Lua中的require与package.loaded</a><time datetime="2025-04-02T15:45:00.000Z" title="发表于 2025-04-02 23:45:00">2025-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/02/Passage/Note7/" title="基础知识7"><img src="/img/xiaoyuan2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础知识7"/></a><div class="content"><a class="title" href="/2025/03/02/Passage/Note7/" title="基础知识7">基础知识7</a><time datetime="2025-03-02T14:00:06.000Z" title="发表于 2025-03-02 22:00:06">2025-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/02/Passage/Note6/" title="基础知识6"><img src="/img/xiaoyuan.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础知识6"/></a><div class="content"><a class="title" href="/2025/03/02/Passage/Note6/" title="基础知识6">基础知识6</a><time datetime="2025-03-02T14:00:05.000Z" title="发表于 2025-03-02 22:00:05">2025-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/02/Passage/Note5/" title="基础知识5"><img src="/img/kon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础知识5"/></a><div class="content"><a class="title" href="/2025/03/02/Passage/Note5/" title="基础知识5">基础知识5</a><time datetime="2025-03-02T14:00:04.000Z" title="发表于 2025-03-02 22:00:04">2025-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/02/Passage/Note4/" title="基础知识4"><img src="/img/huiyuan1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础知识4"/></a><div class="content"><a class="title" href="/2025/03/02/Passage/Note4/" title="基础知识4">基础知识4</a><time datetime="2025-03-02T14:00:03.000Z" title="发表于 2025-03-02 22:00:03">2025-03-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/heita1.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Megumin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="12967630832" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-loop="all" data-preload="auto" data-volume="0.4"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>